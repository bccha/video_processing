# 디버깅 로그: 비디오 DMA 및 FIFO 통합
[**English**](./TRYERROR.md) | [**한국어**]

이 문서는 비디오 DMA 파이프라인 검증 과정에서 발생한 문제들과 그에 대한 해결책을 기록합니다.

## 1. FIFO 사용량 계산 오류 (치명적 RTL 버그)
- **구성 요소**: `RTL/simple_dcfifo.v`
- **증상**: DMA 마스터가 예측 불가능하게 메모리 읽기를 중단하거나(`CHECK_FIFO` 상태에서 멈춤) FIFO 오버플로우가 발생함.
- **원인**: 서로 다른 코딩 체계를 혼용한 잘못된 산술 연산. **그레이 코드(Gray Code)** 포인터에서 **바이너리(Binary)** 포인터를 직접 빼서 사용량(`wrusedw`)을 계산함.
    ```verilog
    // BAD CODE
    assign wrusedw = wr_ptr_bin - rd_ptr_gray_sync; 
    ```
    그레이 코드는 가중치 기반이 아니기 때문에(예: 3은 `0010`, 4는 `0110`), 뺄셈 결과가 무의미한 값이 됨.
- **해결책**: 동기화된 읽기 포인터를 뺄셈 전 바이너리로 변환하는 `gray2bin` 함수를 구현함.
    ```verilog
    // FIXED CODE
    wire [ADDR_WIDTH:0] rd_ptr_bin_sync = gray2bin(rd_ptr_gray_sync2);
    assign wrusedw = (used_diff[ADDR_WIDTH]) ? {ADDR_WIDTH{1'b1}} : used_diff[ADDR_WIDTH-1:0]; // 포화(Saturation) 로직 포함
    ```

## 2. 암시적 넷(Net) 선언 및 비트 절삭
- **구성 요소**: `RTL/video_pipeline.v`
- **증상**: 통합 테스트는 실행되지만 데이터 검증이 완전히 실패함(쓰레기 값 또는 0 수신).
- **원인**: 다중 비트 내부 신호에 대한 `wire` 선언 누락.
    Verilog는 선언되지 않은 신호를 기본적으로 **1비트 wire**로 간주함.
    32비트 `fifo_wr_data`와 9비트 `fifo_used` 신호가 암시적으로 1비트로 선언되어 상위 비트들이 자동으로 버려짐.
- **해결책**: 모든 내부 연결 신호에 대해 명시적인 wire 선언을 추가함.
    ```verilog
    wire [31:0] fifo_wr_data;
    wire [8:0]  fifo_used;
    // ...
    ```

## 3. 시뮬레이션 'X' 전파 문제
- **구성 요소**: `RTL/simple_dcfifo.v` 및 `cocotb`
- **증상**: Python 테스트벤치가 `ValueError: Cannot convert Logic('X') to bool` 에러와 함께 충돌함.
- **원인**: 하드웨어에서 레지스터는 초기 전원 투입 시 알 수 없는 상태('X')를 가짐. 실제 하드웨어는 리셋을 통해 안정화되지만, 시뮬레이션(Cocotb)은 4-상태 로직을 엄격하게 적용함. FIFO 출력 `q`가 첫 읽기 전까지 'X' 상태를 유지하여 테스트벤치 비교기에서 충돌이 발생함.
- **해결책**: 시뮬레이션 목적으로 출력 레지스터를 `0`으로 초기화하는 `initial` 블록을 추가함.
    ```verilog
    initial begin
        q = 0; // X 전파 방지
    end
    ```

## 4. 테스트벤치 버스 경합 (Bus Contention)
- **구성 요소**: `tests/cocotb/tb_dma_master.py` (Avalon Memory Model)
- **증상**: 버스트 전송 중에 메모리에서 읽어온 데이터가 손상되거나 소실됨.
- **원인**: 초기 테스트벤치에서 *모든* 읽기 요청에 대해 새로운 독립적인 로직 스레드(`cocotb.start_soon`)를 생성함. DMA 파이프라인에서 요청이 빠르게 연달아 발생할 경우, 이 스레드들이 공유된 `m_readdata` 버스 신호를 동시에 구동하려고 시도함(버스 경합 발생).
- **해결책**: 메모리 모델을 **큐(Queue)** 기반으로 리팩토링함.
    1.  `Monitor`: 읽기 요청을 `Queue`에 넣음.
    2.  `Driver`: 단일 스레드가 `Queue`에서 요청을 꺼내 차례대로 버스 응답을 구동함.

## 5. 클록 도메인 교차(CDC) 및 지연 시간
- **구성 요소**: `tests/cocotb/tb_video_integration.py`
- **증상**: 프레임 시작 부분에서 픽셀 데이터 불일치 발생 (Pixel 0 값이 틀림).
- **원인**: 비동기 FIFO는 본질적으로 **1사이클의 읽기 지연(Latency)**을 가짐. `rdreq`가 활성화되면 데이터는 한 클록 뒤에 `q`에 나타남. 테스트벤치가 `rdreq`와 동일한 사이클에서 `q`를 확인하여 오류가 발생함.
- **해결책**: 프레임 시작 시퀀스(`0, 1, 2...`)가 한 사이클 지연되더라도 이를 올바르게 인식할 수 있도록 테스트벤치 픽셀 체커를 "지연 허용(Latency tolerant)" 방식으로 업데이트함.

## 6. HDMI 파이프라인 깊이 불일치 (1픽셀 시프트)
- **구성 요소**: `RTL/hdmi_sync_gen.v`
- **증상**: 시뮬레이션에서 픽셀이 오른쪽으로 1~2칸 밀려 보임 (예: 960번째 픽셀이 0번 라인의 마지막 픽셀로 나타남).
- **원인**: 제어 신호(`DE`, `HS`, `VS`)는 3단계 파이프라인 레지스터를 거치지만, 픽셀 데이터 경로는 2사이클 지연만을 가짐. 이로 인해 제어 신호가 데이터보다 뒤처지게 됨.
- **해결책**: `hdmi_sync_gen.v`에서 `hdmi_de`, `hdmi_hs`, `hdmi_vs`의 파이프라인 깊이를 **2단계**로 축소함.

## 7. DMA 다중 프레임 랩어라운드 실패
- **구성 요소**: `RTL/video_dma_master.v`
- **증상**: 0번 프레임은 정상 검증되지만, 1번 프레임이 잘못된 메모리 주소(이미지 중간)에서 시작함.
- **원인**: DMA 마스터의 기본 파라미터가 `H_RES=1280`, `V_RES=720`으로 하드코딩되어 있었음. `video_pipeline.v`에서 이를 재정의하지 않아 DMA가 프레임 종료 카운트(921,600 워드)에 도달하지 못했고, 다음 V-Sync에서 주소 리셋이 트리거되지 않음.
- **해결책**: `video_pipeline.v`에서 정확한 파라미터(`960x540`, 약 518,400 워드)를 전달하도록 수정함.

## 8. 테스트벤치 샘플링 정확도 (Cocotb)
- **구성 요소**: `tests/cocotb/tb_video_integration.py`
- **증상**: 시뮬레이션 결과가 불안정하여 가끔 1픽셀씩 밀리거나 정상으로 나옴.
- **원인**: 시뮬레이션에서 `RisingEdge` 직후에 레지스터 신호를 바로 샘플링하면 델타 사이클 이슈(경합 조건)가 발생하기 쉬움.
- **해결책**: `RisingEdge` 이후 `await ReadOnly()` 트리거를 사용하여 현재 델타 사이클의 모든 신호가 안정화된 후에 샘플링을 수행하도록 구현함.
