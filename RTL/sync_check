/*
 * 1364-1995 Verilog generated by Icarus Verilog VLOG95 Code Generator,
 * Version: 11.0 (stable) ()
 * Converted using TYPICAL delays and without signed support.
 */

`timescale 1ns/1ps
/* This module was originally defined in file hdmi_sync_gen.v at line 6. */
module hdmi_sync_gen(clk, reset_n, hdmi_d, hdmi_de, hdmi_hs, hdmi_vs, avs_address, avs_read, avs_write, avs_writedata, avs_readdata, avs_readdatavalid, reg_mode_out, dma_enable_out, shadow_ptr_out, stream_data_in, stream_rd_en, dma_busy, dma_done_in, dma_start_out, dma_cont_en_out);
  input clk;
  input reset_n;
  output [23:0] hdmi_d;
  output hdmi_de;
  output hdmi_hs;
  output hdmi_vs;
  input [2:0] avs_address;
  input avs_read;
  input avs_write;
  input [31:0] avs_writedata;
  output [31:0] avs_readdata;
  output avs_readdatavalid;
  output [31:0] reg_mode_out;
  output dma_enable_out;
  output [31:0] shadow_ptr_out;
  input [23:0] stream_data_in;
  output stream_rd_en;
  input dma_busy;
  input dma_done_in;
  output dma_start_out;
  output dma_cont_en_out;

  parameter H_BACK = 220;
  parameter H_FRONT = 110;
  parameter H_SYNC = 40;
  parameter H_TOTAL = 1650;
  parameter H_VISIBLE = 1280;
  parameter V_BACK = 20;
  parameter V_FRONT = 5;
  parameter V_SYNC = 5;
  parameter V_TOTAL = 750;
  parameter V_VISIBLE = 720;

  wire [2:0] avs_address;
  wire avs_read;
  wire [31:0] avs_readdata;
  reg avs_readdatavalid;
  wire avs_write;
  wire [31:0] avs_writedata;
  wire [2:0] bar_idx;
  reg [15:0] char_bitmap [0:15];
  wire [3:0] char_col_idx;
  wire [23:0] char_color;
  wire char_pixel;
  wire [3:0] char_row_idx;
  wire clk;
  wire [15:0] current_row_bits;
  wire dma_busy;
  wire dma_cont_en_out;
  wire dma_done_in;
  reg dma_done_sticky;
  wire dma_enable_out;
  wire dma_start_out;
  reg dma_start_pulse;
  wire [7:0] fancy_b;
  wire [7:0] fancy_g;
  wire [7:0] fancy_r;
  wire [7:0] gamma_b;
  wire [7:0] gamma_g;
  wire [7:0] gamma_r;
  wire [7:0] gray;
  wire [7:0] gray8_val;
  wire grid_line;
  reg [11:0] h_cnt;
  reg [23:0] hdmi_d;
  reg hdmi_de;
  reg hdmi_hs;
  reg hdmi_vs;
  wire hs_wire;
  reg [7:0] lut_mem [0:255];
  reg [23:0] pre_gamma_d;
  reg [31:0] read_data_mux;
  reg [31:0] reg_bitmap_addr;
  reg [31:0] reg_bitmap_data;
  reg [31:0] reg_frame_ptr;
  reg [31:0] reg_global_ctrl;
  reg [31:0] reg_lut_addr;
  reg [31:0] reg_lut_data;
  reg [31:0] reg_mode;
  wire [31:0] reg_mode_out;
  wire reset_n;
  reg [31:0] shadow_ptr;
  wire [31:0] shadow_ptr_out;
  wire [23:0] stream_data_in;
  wire stream_rd_en;
  reg [11:0] v_cnt;
  wire visible;
  wire vs_edge;
  reg vs_prev;
  reg vs_toggle;
  wire vs_wire;


  assign dma_enable_out = reg_global_ctrl[1];
  assign dma_cont_en_out = reg_global_ctrl[1];
  assign gray = h_cnt[7:0];
  assign bar_idx = ((32'h000000a0 > {20'h00000, h_cnt}) ? 3'h0 : ((32'h00000140 > {20'h00000, h_cnt}) ? 3'h1 : ((32'h000001e0 > {20'h00000, h_cnt}) ? 3'h2 : ((32'h00000280 > {20'h00000, h_cnt}) ? 3'h3 : ((32'h00000320 > {20'h00000, h_cnt}) ? 3'h4 : ((32'h000003c0 > {20'h00000, h_cnt}) ? 3'h5 : ((32'h00000460 > {20'h00000, h_cnt}) ? 3'h6 : 3'h7)))))));
  assign gray8_val = {bar_idx, 5'h00};
  assign char_row_idx = v_cnt[5:2];
  assign char_col_idx = h_cnt[5:2];
  assign char_pixel = current_row_bits[(32'h0000000f - {28'h0000000, char_col_idx})];
  assign fancy_r = (h_cnt[7:0] + v_cnt[7:0]);
  assign fancy_g = h_cnt[9:2];
  assign fancy_b = v_cnt[9:2];
  assign char_color = (char_pixel ? {fancy_r, fancy_g, fancy_b} : 24'h000000);
  assign reg_mode_out = reg_mode;
  assign dma_start_out = dma_start_pulse;
  assign shadow_ptr_out = shadow_ptr;
  assign avs_readdata = read_data_mux;
  assign visible = ((H_VISIBLE > {20'h00000, h_cnt}) & (V_VISIBLE > {20'h00000, v_cnt}));
  assign hs_wire = (({20'h00000, h_cnt} >= 32'h0000056e) & (32'h00000596 > {20'h00000, h_cnt}));
  assign vs_wire = (({20'h00000, v_cnt} >= 32'h000002d5) & (32'h000002da > {20'h00000, v_cnt}));
  assign vs_edge = (vs_wire & (~|vs_prev));
  assign gamma_r = lut_mem[{2'h0, pre_gamma_d[23:16]} + 0];
  assign gamma_g = lut_mem[{2'h0, pre_gamma_d[15:8]} + 0];
  assign gamma_b = lut_mem[{2'h0, pre_gamma_d[7:0]} + 0];
  assign grid_line = ((h_cnt[5:0] == 6'h00) | (v_cnt[5:0] == 6'h00));
  assign current_row_bits = char_bitmap[{2'h0, char_row_idx} + 0];
  assign stream_rd_en = (visible & (reg_mode[3:0] == 4'h8));

  always @(avs_address or reg_mode or dma_busy or dma_done_sticky or reg_global_ctrl or reg_lut_addr or reg_lut_data or reg_bitmap_addr or reg_bitmap_data or reg_frame_ptr) case (avs_address)
    3'h0: read_data_mux = reg_mode;
    3'h1: read_data_mux = {dma_busy, dma_done_sticky, 28'h0000000, reg_global_ctrl[1], reg_global_ctrl[0]};
    3'h2: read_data_mux = reg_lut_addr;
    3'h3: read_data_mux = reg_lut_data;
    3'h4: read_data_mux = reg_bitmap_addr;
    3'h5: read_data_mux = reg_bitmap_data;
    3'h6: read_data_mux = reg_frame_ptr;
    default: read_data_mux = 32'h00000000;
  endcase

  always @(posedge clk or negedge reset_n) if ((!reset_n)) begin
    reg_mode <= 32'h00000000;
    reg_global_ctrl <= 32'h00000000;
    reg_lut_addr <= 32'h00000000;
    reg_lut_data <= 32'h00000000;
    reg_frame_ptr <= 32'h30000000;
    avs_readdatavalid <= 1'b0;
    dma_start_pulse <= 1'b0;
    dma_done_sticky <= 1'b0;
    char_bitmap[0] <= 16'h0000;
    char_bitmap[1] <= 16'h0000;
    char_bitmap[2] <= 16'h0000;
    char_bitmap[3] <= 16'h0000;
    char_bitmap[4] <= 16'h0000;
    char_bitmap[5] <= 16'h0000;
    char_bitmap[6] <= 16'h0000;
    char_bitmap[7] <= 16'h0000;
    char_bitmap[8] <= 16'h0000;
    char_bitmap[9] <= 16'h0000;
    char_bitmap[10] <= 16'h0000;
    char_bitmap[11] <= 16'h0000;
    char_bitmap[12] <= 16'h0000;
    char_bitmap[13] <= 16'h0000;
    char_bitmap[14] <= 16'h0000;
    char_bitmap[15] <= 16'h0000;
  end
  else begin
    dma_start_pulse <= 1'b0;
    if (dma_done_in) dma_done_sticky <= 1'b1;
    if (avs_write) case (avs_address)
      3'h0: reg_mode <= avs_writedata;
      3'h1: begin
        reg_global_ctrl <= avs_writedata;
        if (avs_writedata[2]) dma_start_pulse <= 1'b1;
        if (avs_writedata[30]) dma_done_sticky <= 1'b0;
      end
      3'h2: reg_lut_addr <= avs_writedata;
      3'h3: begin
        reg_lut_data <= avs_writedata;
        lut_mem[reg_lut_addr[7:0]] <= avs_writedata[7:0];
      end
      3'h4: reg_bitmap_addr <= avs_writedata;
      3'h5: begin
        reg_bitmap_data <= avs_writedata;
        char_bitmap[reg_bitmap_addr[3:0]] <= avs_writedata[15:0];
      end
      3'h6: reg_frame_ptr <= avs_writedata;
      default:;
    endcase
    avs_readdatavalid <= avs_read;
  end

  always @(posedge clk or negedge reset_n) if ((!reset_n)) h_cnt <= 12'h000;
  else if ((h_cnt == 32'h00000671)) h_cnt <= 12'h000;
  else h_cnt <= (h_cnt + 12'h001);

  always @(posedge clk or negedge reset_n) if ((!reset_n)) v_cnt <= 12'h000;
  else if ((h_cnt == 32'h00000671)) if ((v_cnt == 32'h000002ed)) v_cnt <= 12'h000;
  else v_cnt <= (v_cnt + 12'h001);

  always @(posedge clk or negedge reset_n) if ((!reset_n)) begin
    hdmi_hs <= 1'b0;
    hdmi_vs <= 1'b0;
    hdmi_de <= 1'b0;
    vs_prev <= 1'b0;
  end
  else begin
    hdmi_hs <= hs_wire;
    hdmi_vs <= vs_wire;
    hdmi_de <= visible;
    vs_prev <= vs_wire;
  end

  always @(posedge clk or negedge reset_n) if ((!reset_n)) begin
    shadow_ptr <= 32'h30000000;
    vs_toggle <= 1'b0;
  end
  else if (vs_edge) begin
    shadow_ptr <= reg_frame_ptr;
    vs_toggle <= (~vs_toggle);
  end

  always @(reg_mode or gray or grid_line or gray8_val or char_color) case (reg_mode[3:0])
    4'h0: pre_gamma_d = 24'hff0000;
    4'h1: pre_gamma_d = 24'h00ff00;
    4'h2: pre_gamma_d = 24'h0000ff;
    4'h3: pre_gamma_d = {gray, gray, gray};
    4'h4: pre_gamma_d = (grid_line ? 24'hffffff : 24'h000000);
    4'h5: pre_gamma_d = 24'hffffff;
    4'h6: pre_gamma_d = {gray8_val, gray8_val, gray8_val};
    4'h7: pre_gamma_d = char_color;
    default: pre_gamma_d = 24'hffffff;
  endcase

  always @(posedge clk or negedge reset_n) if ((!reset_n)) hdmi_d <= 24'h000000;
  else if (visible) if (reg_global_ctrl[0]) hdmi_d <= {gamma_r, gamma_g, gamma_b};
  else if ((reg_mode[3:0] == 4'h8)) hdmi_d <= stream_data_in;
  else hdmi_d <= pre_gamma_d;
  else hdmi_d <= 24'h000000;
endmodule  /* hdmi_sync_gen */
