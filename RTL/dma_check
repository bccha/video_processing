/*
 * 1364-1995 Verilog generated by Icarus Verilog VLOG95 Code Generator,
 * Version: 11.0 (stable) ()
 * Converted using TYPICAL delays and without signed support.
 */

`timescale 1ns/1ps
/* This module was originally defined in file video_dma_master.v at line 3. */
module video_dma_master(clk, reset_n, start_addr, dma_start, dma_cont_en, dma_done, busy, vsync_edge, m_waitrequest, m_readdata, m_readdatavalid, m_address, m_read, m_burstcount, fifo_used, fifo_wr_en, fifo_wr_data);
  input clk;
  input reset_n;
  input [31:0] start_addr;
  input dma_start;
  input dma_cont_en;
  output dma_done;
  output busy;
  input vsync_edge;
  input m_waitrequest;
  input [31:0] m_readdata;
  input m_readdatavalid;
  output [31:0] m_address;
  output m_read;
  output [7:0] m_burstcount;
  input [8:0] fifo_used;
  output fifo_wr_en;
  output [31:0] fifo_wr_data;

  parameter BURST_LEN = 8'h40;
  parameter CHECK_FIFO = 2'h1;
  parameter FIFO_DEPTH = 512;
  parameter FRAME_SIZE_WORDS = 921600;
  parameter H_RES = 1280;
  parameter IDLE = 2'h0;
  parameter ISSUE_READ = 2'h2;
  parameter V_RES = 720;
  parameter WAIT_END = 2'h3;

  wire busy;
  wire clk;
  reg [31:0] current_read_addr;
  wire dma_cont_en;
  reg dma_done;
  wire dma_start;
  wire [8:0] fifo_used;
  wire [31:0] fifo_wr_data;
  wire fifo_wr_en;
  reg frame_active;
  reg is_cont_mode;
  reg [31:0] m_address;
  wire [7:0] m_burstcount;
  reg m_read;
  wire [31:0] m_readdata;
  wire m_readdatavalid;
  wire m_waitrequest;
  reg [9:0] pending_bursts;
  wire reset_n;
  wire [31:0] start_addr;
  reg [1:0] state;
  wire vsync_edge;
  reg [31:0] words_commanded;
  reg [31:0] words_received;


  assign m_burstcount = BURST_LEN;

  assign fifo_wr_en = m_readdatavalid;
  assign fifo_wr_data = m_readdata;
  assign busy = frame_active;

  always @(posedge clk or negedge reset_n) if ((!reset_n)) begin
    state <= IDLE;
    m_address <= 32'h00000000;
    m_read <= 1'b0;
    current_read_addr <= 32'h00000000;
    words_commanded <= 32'h00000000;
    is_cont_mode <= 1'b0;
    frame_active <= 1'b0;
    pending_bursts <= 10'h000;
  end
  else begin
    case (state)
      IDLE: begin
        m_read <= 1'b0;
        words_commanded <= 32'h00000000;
        if (dma_start) begin
          current_read_addr <= start_addr;
          is_cont_mode <= 1'b0;
          frame_active <= 1'b1;
          state <= CHECK_FIFO;
        end
        else if ((dma_cont_en && vsync_edge)) begin
          current_read_addr <= start_addr;
          is_cont_mode <= 1'b1;
          frame_active <= 1'b1;
          state <= CHECK_FIFO;
        end
        else frame_active <= 1'b0;
      end
      CHECK_FIFO: begin
        m_read <= 1'b0;
        if ((words_commanded >= FRAME_SIZE_WORDS)) state <= WAIT_END;
        else if (((fifo_used + (words_commanded - words_received)) <= 32'h000001be)) begin
          m_address <= current_read_addr;
          m_read <= 1'b1;
          state <= ISSUE_READ;
        end
      end
      ISSUE_READ: if ((!m_waitrequest)) begin
        m_read <= 1'b0;
        current_read_addr <= (current_read_addr + 32'h00000100);
        words_commanded <= (words_commanded + BURST_LEN);
        state <= CHECK_FIFO;
      end
      WAIT_END: begin
        m_read <= 1'b0;
        if ((words_received >= FRAME_SIZE_WORDS)) begin
          state <= IDLE;
          frame_active <= 1'b0;
        end
      end
    endcase
    if (((is_cont_mode && (!dma_cont_en)) && (state == IDLE))) is_cont_mode <= 1'b0;
  end

  always @(posedge clk or negedge reset_n) if ((!reset_n)) words_received <= 32'h00000000;
  else begin
    if (((state == IDLE) && (dma_start || (dma_cont_en && vsync_edge)))) words_received <= 32'h00000000;
    if (m_readdatavalid) words_received <= (words_received + 32'h00000001);
  end

  always @(posedge clk or negedge reset_n) if ((!reset_n)) dma_done <= 1'b0;
  else if ((m_readdatavalid && (words_received == 64'h00000000000e0fff))) dma_done <= 1'b1;
  else dma_done <= 1'b0;
endmodule  /* video_dma_master */
