# 버스트 마스터 DMA: 시행착오와 성공의 기록
[**English**](./BURST_DMA.md) | [**한국어**]
[⬅️ README로 돌아가기](../README_kor.md)

이 문서는 DE10-Nano 비디오 프로세싱 프로젝트를 위한 DDR3 연결 전략의 기술적 과제와 발전 과정을 기록합니다.

## 1. 초기 문제: "DDR 행(Hang)" 현상
Nios II 또는 버스트 마스터가 **FPGA-to-SDRAM Bridge (Port 0)**를 통해 DDR3를 읽으려고 시도할 때 전체 Avalon 버스가 멈추는 현상이 발생했습니다. JTAG UART가 응답을 멈추고 Nios II 프로세서가 정지되었습니다.

### 🔍 진단 및 확인
- **레지스터 점검**: HPS `sysmgr.f2s_port_en` 레지스터는 어떤 FPGA-to-SDRAM 포트를 활성화할지 제어합니다.
    - **예상 값**: 포트 0은 `0x01`, 포트 1은 `0x02`, 세 개 모두는 `0x07`.
    - **결과**: 프리로더(U-Boot SPL)가 이 값을 `0x02`(포트 1만 사용)로 고정해두었습니다. 포트 0을 사용했기 때문에 시스템이 멈춘 것이었습니다!

#### 포트 상태 확인 방법
1. **U-Boot에서**:
   ```bash
   # f2s_port_en 레지스터(0xffd08040)에서 1워드 읽기
   md 0xffd08040 1
   ```
2. **리눅스에서**:
   ```bash
   # devmem2 유틸리티 사용
   devmem2 0xffd08040
   ```

---

### 🛠️ 부팅 설정: 부팅 인자 (bootargs)
`mem=512M`과 같은 메모리 예약은 HPS가 비디오 버퍼를 덮어쓰지 않도록 하는 데 매우 중요합니다.

#### 1. U-Boot에서 (대화형)
U-Boot 프롬프트에서 변수를 직접 제어할 수 있습니다:
- **확인**: `printenv bootargs`
- **설정**: `setenv bootargs 'console=ttyS0,115200 mem=512M root=${mmcroot} rw rootwait'`
- **저장**: `saveenv` (영구 변경)

#### 2. 리눅스에서 (정적)
부트로더는 보통 SD 카드의 FAT 파티션에 있는 `uEnv.txt`를 읽습니다.
- **위치**: /mnt/boot/uEnv.txt (또는 유사한 경로)
- **내용**: `mmcbootargs` 또는 `bootargs`로 시작하는 라인을 찾으세요.
- **현재 인자 확인**: `cat /proc/cmdline`

---

## 2. 시도 1: SDRAM 포트 1로 전환
`f2h_sdram0` 대신 `f2h_sdram1`을 사용하도록 Qsys를 수정했습니다.
- **결과**: 여전히 실패.
- **걸림돌**: 리눅스 커널의 `fpga_bridge` 드라이버(특히 `br3`)가 명시적으로 활성화되지 않으면 브릿지를 리셋 상태로 유지합니다. 그러나 `/sys/class/fpga_bridge`를 통한 브릿지 제어는 루트 권한이나 프리로더 수정 없이는 잠겨 있거나 접근이 불가능했습니다.

---

## 3. 시도 2: F2H AXI 브릿지로 재배치 (성공!)
전용 SDRAM 포트를 포기하고 **FPGA-to-HPS AXI Slave Bridge**로 전환했습니다.
- **전략**: Qsys에서 AXI 브릿지를 활성화하고 모든 DDR3 트래픽을 HPS L3 인터커넥트를 통해 라우팅합니다.
- **결과**: **성공**. AXI 브릿지는 일반적으로 GHRD 환경에서 초기화되어 개방되어 있으므로 DDR3에 대한 신뢰할 수 있는 양방향 경로를 제공합니다.

---

## 4. 소프트웨어 구현 시 과제

### 🛑 과제 1: "자가 파괴" 버그 (OCM 덮어쓰기)
- **문제**: 초기 테스트 코드가 데이터를 `ONCHIP_MEMORY2_0_BASE` (0x0) 주소에 썼습니다.
- **오류**: Nios II의 리셋 벡터와 코드는 주소 `0x0`에 위치합니다. 버스트 마스터 벤치마크가 Nios II가 실행 중인 명령어를 덮어쓰면서 크래시가 발생했습니다.
- **해결책**: **정적 전역 배열**(`src_buffer`)을 사용하여 링커가 안전한 메모리 위치를 할당하도록 했습니다.

### 🛑 과제 2: 캐시 일관성 (보이지 않는 데이터)
- **문제**: Nios II가 OCM에 데이터를 썼지만, 버스트 마스터(하드웨어)가 이전 값이나 랜덤한 데이터를 읽었습니다.
- **원인**: 데이터가 Nios II 데이터 캐시에만 머물러 있고 물리적인 OCM RAM에는 아직 기록되지 않았기 때문입니다.
- **해결책**: DMA 동작을 트리거하기 전에 `alt_dcache_flush_all()`을 추가했습니다.

### 🛑 과제 3: 메모리 용량 제한
- **문제**: 64KB 테스트 버퍼 사용 시 링커 오류(`section .bss is not within region onchip_memory2_0`)가 발생했습니다.
- **원인**: DE10-Nano GHRD의 OCM은 약 100KB입니다. 코드 + 스택 + 64KB 버퍼는 용량을 초과했습니다.
- **해결책**: 버퍼를 **4KB**로 줄이고 테스트를 **100번 반복**하여 타이밍 정확도를 유지했습니다.

---

## 5. 최종 결과 및 벤치마크
하드웨어 구동 DMA로 전환하면서 성능이 비약적으로 향상되었습니다. 4KB 전송을 **100번 반복**하여 소프트웨어와 하드웨어 경로 모두에 대해 안정적인 지표를 얻었습니다.

### 📊 비교 분석
| 방법 | 총 데이터 | 시간 (ms) | 처리량 (MB/s) |
| :--- | :--- | :--- | :--- |
| **소프트웨어 복사** (CPU 루프) | 400 KB | 90.00 ms | 4.55 MB/s |
| **버스트 마스터 (DMA)** | **400 KB** | **3.00 ms** | **136.53 MB/s** |

### 왜 `burst_master`가 훨씬 빠른가요?
1. **버스트 전송**: 표준 Nios II I/O 명령어는 단일 비트 트랜잭션(주소 -> 데이터)을 수행합니다. 반면 `burst_master`는 **주소 하나**를 보내고 **최대 64개의 데이터 워드**를 연속해서 읽거나 써서 버스 점유율을 극대화합니다.
2. **전용 하드웨어**: Nios II가 명령어를 가져오고 루프 카운터를 관리하느라 바쁜 동안, `burst_master`는 순수하게 데이터 구동 방식으로 동작하며 내부 FIFO를 활용해 버퍼링과 파이프라이닝을 수행합니다.
3. **AXI 브릿지 효율성**: FPGA-to-HPS AXI 브릿지는 고성능 버스트에 최적화되어 있어, 하드웨어 마스터가 동일한 경로를 통한 소프트웨어 마스터의 단일 비트 액세스보다 훨씬 낮은 지연 시간으로 DDR3에 도달할 수 있게 해줍니다.

---

## 6. 2단계: DDR-to-DDR 파이프라인 DMA 및 메모리 보호
단순한 데이터 전송을 넘어, 4단계 산술 파이프라인을 포함하는 `burst_master_4`를 사용하여 픽셀 처리 성능을 측정했습니다. 이 테스트는 계수를 곱한 뒤 400으로 나누는 연산(`Pixel_Out = (Pixel_In * Coeff) / 400`)을 수행하며, 이는 비디오 필터 및 색 공간 변환 알고리즘의 기초가 됩니다. 또한 HPS(ARM/리눅스) 시스템 영역을 침범하지 않기 위해 메모리 보호 전략을 구현했습니다.

### 🛑 과제 4: HPS 메모리 충돌 (0x0 주소)
- **문제**: 물리 주소 0x0은 ARM 벡터 테이블과 커널을 위해 예약되어 있습니다. DMA를 통해 이 영역에 쓰기를 시도하면 즉각적인 시스템 크래시가 발생합니다.
- **해결책**: 모든 DMA 테스트 주소를 **512MB (0x20000000)**부터 시작하는 안전한 영역으로 옮겼습니다.
- **구현**: 시작 시 `Address Span Extender` 윈도우 베이스를 `0x20000000`으로 초기화하여 Nios II와 하드웨어 DMA 간의 정렬을 보장했습니다.

### 📊 DDR-to-DDR 벤치마크 (1 MB)
| 방법 | 전송 크기 | 시간 | 처리량 | 속도 향상 |
| :--- | :--- | :--- | :--- | :--- |
| **소프트웨어 복사** (나눗셈 포함) | 1 MB | 4.683 s | 0.21 MB/s | 기준점 |
| **하드웨어 DMA** (4단계) | **1 MB** | **0.008 s** | **125.00 MB/s** | **약 585배** |

---

## 7. 결론
**AXI 브릿지**와 **버스트 마스터 DMA**의 조합은 DE10-Nano에서 DDR3 리소스를 활용하는 가장 안정적이고 고성능인 방법입니다. 검증된 125 MB/s의 처리량은 실시간 720p HD 비디오 스트리밍에 충분하며, 산술 파이프라인과의 성공적인 통합은 고급 이미지 처리 작업에 대한 준비가 되었음을 입증합니다.

---

## 부록: 리눅스 HPS FPGA-to-SDRAM 브릿지 전역 수정 방법
시스템 안정성을 위해 부트로더(U-Boot)에서 브릿지 포트를 비활성화하거나 리셋 상태로 두는 경우가 많습니다. Qsys 설정이 올바른데도 DMA가 멈춘다면, 이 리눅스 C 프로그램을 사용하여 포트 리셋을 강제로 해제할 수 있습니다.

### [수정 코드] bridge_fix.c
```c
#include <fcntl.h>
#include <stdio.h>
#include <sys/mman.h>
#include <unistd.h>

#define REG_BASE 0xFFC20000     // SDR 컨트롤러 베이스 주소
#define REG_SPAN 0x10000
#define RESET_REG_OFFSET 0x5080 // fpgaportrst 레지스터
#define PORT_EN_OFFSET 0x505C   // f2s_port_en 레지스터

int main() {
  int fd;
  void *map_base;
  volatile unsigned int *reset_reg;
  volatile unsigned int *port_en_reg;

  fd = open("/dev/mem", O_RDWR | O_SYNC);
  // ... (생략)

  reset_reg = (volatile unsigned int *)(map_base + RESET_REG_OFFSET);
  port_en_reg = (volatile unsigned int *)(map_base + PORT_EN_OFFSET);

  // 1. 모든 포트의 리셋 해제 (fpgaportrst에 0 쓰기)
  if (*reset_reg != 0) {
    *reset_reg = 0x00000000;
  }
  // ... (생략)
  return 0;
}
```

> [!IMPORTANT]
> **현재 AXI 브릿지 설정에서도 이 코드가 필요한가요?**
> 엄밀히 말하면 **아니요.** 성공한 '시도 2'는 이러한 전용 SDRAM 포트 제어를 우회하는 **FPGA-to-HPS AXI Slave Bridge**를 사용했습니다. 이것이 시도 2가 즉시 성공한 이유입니다!
>
> **그럼 왜 이 내용을 남겨두었나요?**
> 1. **시도 1 사후 분석**: 포트 0을 사용한 첫 시도가 왜 멈췄는지 정확히 설명해줍니다.
> 2. **성능 튜닝**: 전용 SDRAM 포트는 AXI 브릿지보다 지연 시간이 더 짧습니다. 나중에 극한의 DDR3 성능이 필요하다면 이 포트들과 이 수정 코드가 필요할 것입니다!
